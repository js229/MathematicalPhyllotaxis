(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];
Get["Packages\\TextbookFigurePreamble.wl"] ;
Get["LatticePhyllotaxis`",Path->FileNameJoin[PersistentSymbol["persistentGitHubPath"],"GeometricalPhyllotaxis\\Mathematica\\Packages"]];



(* ::Input::Initialization:: *)

figureStyle = jStyle
jParastichyColour[n_] := figureStyle["ParastichyColour"][n];
jFont[n_] := {FontFamily->figureStyle["FontFamily"],FontSize->n};

rebuildingData = True;
getTextbookData[name_] := Module[{data=PersistentSymbol["TextbookData"] },data[name]];
setTextbookData[name_,value_] := Module[{data},
data=PersistentSymbol["TextbookData"] ;
data = Append[data,name->value];
PersistentSymbol["TextbookData"] = data;
];

If[rebuildingData,PersistentSymbol["TextbookData"] =<||>]


(* ::Input::Initialization:: *)
exportFigures := {
jExport[Ch5Transition];
jExport[Ch5Transforms];
jExport[Ch5PineSet];
jExport[Ch5FibScalingBar];
jExport[Ch5Bulge4];
}
shExport[x_] := x;


(* ::Input::Initialization:: *)
fpair[n_] := {Fibonacci[n],Fibonacci[n+1]};
data=Map[<|"n"->#, "pair"-> fpair[#],"pairText"->pairToText[fpair[#]], "rise"->1/(Last@vanItersonLabelPoint[fpair[#]])|>&,Table[n,{n,0,12}]] ;
touchingDiskRadius[{m_,n_}] := 1/2 Sqrt[1/(m^2+m n + n^2)]
data= Map[Append[#,"Radius"-> touchingDiskRadius[#pair]]&,data];


(* ::Input::Initialization:: *)
pairToText[{m_,n_}] :=  Style[StringTemplate["(``,``)"][m,n],Directive[FontSize->Scaled[0.03],FontFamily->jStyle["DisplayFontFamily"]]];
Ch5FibScalingBar := Module[{},
Show[ListPlot[Map[{First[#["pair"]],1/#["Radius"]}& ,data],BaseStyle->setFontFamily,
PlotStyle->jParastichyColour[1]
,PlotRange->{{-10,170},{1* 10^0, 10^3}}
,Frame->{{True,False},{True,False}},
FrameLabel->{"Parastichy count" ,"\!\(\*SubscriptBox[\(Log\), \(10\)]\) Circumference"},FrameTicks->{{{1,2,10,100,500},None},{{0,89,144},None}},ScalingFunctions->"Log10"]
,Graphics[Map[Text[#["pairText"],{First[#["pair"]],Log10[1/#["Radius"]]},{-1.5,0}]&,data]]
]
]




(* ::Input::Initialization:: *)
(* a rise scaling  *)
(*linearRiseScalingFallCylinderZ[cylinderLU_,targetz_] :=    Module[{z,eps = 10^-1},
z=  (targetz-cylinderLU[[1]])/(cylinderLU[[2]]-cylinderLU[[1]]);
(  (1-z)  + eps (z))
];
*)
scaleZ01ToCylinder[cylinderLU_,bulgeFunction_] := Module[{zScale},
zScale[cylinderZ_] :=   (cylinderZ-cylinderLU[[1]])/(cylinderLU[[2]]-cylinderLU[[1]]);
Composition[bulgeFunction,zScale]
];
linearRiseFallZ01[z_] :=    Module[{eps = 10^-1},(  (1-z)  + eps (z))];
linearRiseFallZLattice[lattice_,z_] :=    scaleZ01ToCylinder[latticeGetCylinderLU[lattice],linearRiseFallZ01][z];
quadraticRiseFallZLattice[lattice_,z_] := linearRiseFallZLattice[lattice,z]^2;

riseByUnscaledHeightFunction[lattice_] := Module[{heightsBase,risesStretch},
heightsBase =  Drop[Last/@latticePoints[lattice],-1];
risesStretch = Differences[Last/@ latticePoints[lattice,"StemStretch"]];
Interpolation[Transpose[{heightsBase,risesStretch}]]
];

inverseriseByUnscaledHeightFunction[lattice_] := Function[{z},1/riseByUnscaledHeightFunction[lattice][z]];




(* ::Input::Initialization:: *)
(*
riseScalingZCylinder has domain of the z-values of the nodeCylinder (say [0,4] )
Typically riseScalingZCylinder[0]=1, and values higher are the proportions by which the rises are to be stretched

*)
makeLatticeStretchFunction[baseLattice_,riseScalingZCylinder_] := Module[{nodeHeights,targetRiseAtNode,targetNodeHeights,heightScalingAtNodes,latticeScalingFunction,scaledLattice},
nodeHeights = Map[Last,latticePoints[baseLattice]];
targetRiseAtNode = latticeRise[baseLattice]* Map[riseScalingZCylinder,nodeHeights];
targetNodeHeights = Prepend[Drop[Accumulate[targetRiseAtNode],-1],0];
heightScalingAtNodes = Interpolation[Transpose[{nodeHeights,targetNodeHeights}]];
heightScalingAtNodes
];

(*
riseScalingZCylinder has domain [cylinderLU]
*)

makeStretchedLattice[baseLattice_,riseScalingZCylinder_] := Module[{latticeZScalingFunction,latticeScalingFunction,scaledLattice,cylinder,scaledCylinder},
(*riseScalingZCylinder[z_] := riseScaling[latticeGetCylinderLU[baseLattice],z];
*)
latticeZScalingFunction = makeLatticeStretchFunction[baseLattice,riseScalingZCylinder];
latticeScalingFunction = Function[{xz},{xz[[1]],latticeZScalingFunction[xz[[2]]]}];
scaledLattice = baseLattice;
scaledLattice = latticeSetScaling[scaledLattice,"StemStretch"->latticeScalingFunction];
(*latticeScalingFunction maps x,z to x,z *)
scaledCylinder = Transpose[ latticeScalingFunction /@ Transpose[latticeGetCylinder[baseLattice]] ];
scaledLattice = latticeSetDisplayCylinder[scaledLattice,scaledCylinder];
scaledLattice
];


(* ::Input::Initialization:: *)
showStem[lattice_,p2ThroughList_,chains_] := Module[{chainColour},
chainColour = <|"Up"->jParastichyColour[1],"Down"->jParastichyColour[2]|>;
chainColour = <|"Up"->Gray,"Down"->Gray|>;

Show[
Graphics[
{
figureStyle["CylinderColour"],
Rectangle@@Transpose[latticeGetCylinder[lattice]]
}
]
,
MapIndexed[
stemParastichyPlot[lattice,#1[[1]],#1[[2]],Directive[jParastichyColour[First[#2]]]]&,
p2ThroughList]
,Graphics[
{Map[showChain[lattice,#,chainColour]&,chains]
,
{White,Point[latticePoints[lattice,"StemStretch"]]}
(*,KeyValueMap[Text[#1,#2]&,latticeNamedPoints[lattice,"StemStretch"]]
*)}
]
,PlotRangeClipping->True
, Axes->False
,PlotRange->latticeGetCylinder[lattice]
]
];

stemParastichyPlot[lattice_,m_,k_,style_] := Module[{funcs},
funcs =latticeParastichyFunctions[lattice,m,k,"StemStretch"];
Map[ParametricPlot[#[t],{t,0,1},PlotStyle->style,PlotRange->latticeGetNodeCylinder[lattice]]&,funcs]
];



(* ::Input::Initialization:: *)
(* chains work in the scaled space , and we add hats to the right*)

rightPoint[lattice_,pt_,basept_] := Module[{hat},
lp = latticeNamedPoints[lattice,"StemStretch"];
lphat = Association@KeyValueMap[ {hat[#1]->#2+{1,0}}&,lp];
lp = Append[lp,Association[lphat]];
(* point numbers here are not from 0 but sequence count in the results of latticePoints[lattice,"StemStretch"] *)If[!KeyExistsQ[lp,pt],
Return[Missing[Echo[StringTemplate["Point `` not in region"][pt]]]]];
pt1dh= lp[pt];
basedh = lp[basept];
lp= Select[lp, #[[1]]> pt1dh[[1]]&]; (* only to the right of pt *)
If[pt1dh[[2]]>basedh[[2]], (* if above basept, only below pt *)
lp = Select[lp, #[[2]]<=  pt1dh[[2]]&],
lp = Select[lp, #[[2]] >=   pt1dh[[2]]&]];


dist[pt2_]:= Norm[ pt1dh - lp[pt2]];

rpt = First@Keys@Take[Sort@Association@Map[#-> dist[#]&,Keys@lp],1];
rptdh = lp[rpt];
rptBare = rpt/. hat[x_]->x;
wrap = MatchQ[rpt,hat[_]];
If[! wrap,
line= {Line[ {pt1dh,rptdh}]}
,
hinterp = Interpolation[{pt1dh,rptdh},InterpolationOrder->1][1/2];
line ={ Line[{pt1dh,{1/2,hinterp}}],Line[{{-1/2,hinterp},rptdh-{1,0}}]}
];
pt-> <|
"Line"-> line,
"UpDown"-> If[ rptdh[[2]]>= pt1dh[[2]],"Up","Down"],
"Next"->rptBare, 
"Parastichy"->Abs[(rptBare-pt )],
"Wrap"->wrap
 |>
];
makeRightChain[lattice_,n_] :=  Module[{start,chain,i},
start = rightPoint[lattice,n,n];
If[MissingQ[start],Return[start]];
chain = <|start|>;i=0;
While[Length[chain]<200 && i++  < 200,
nextpt = Last[chain]["Next"];
If[MemberQ[Keys[chain],nextpt],Break[]];
AppendTo[chain,rightPoint[lattice,Last[chain]["Next"],n]]];
chain
];
countChainUpDown[chain_] := Module[{},
Counts@Map[#["UpDown"]&,Values[chain]]
];
showChain[lattice_,pt_,colour_] := Module[{chain},
chain = makeRightChain[lattice,pt];
If[MissingQ[chain],Return[Nothing[]]];
makeseg[seg_] := {If[seg["UpDown"]=="Up",jParastichyColour[1],jParastichyColour[2]],seg["Line"]};
makeseg[seg_] := {colour[seg["UpDown"]],seg["Line"]};
Values@Map[makeseg,chain]
];


(* ::Input::Initialization:: *)


showTransitionLattice [lattice_] := Module[{lmax,lattice1,lattice2,lattice3,lattice4},
nsplit = 4;
lmax = latticeGetCylinderLU[lattice][[2]]; 
lattice1 = latticeSetDisplayCylinderLU[lattice,{0,lmax/nsplit}];
lattice2 = latticeSetDisplayCylinderLU[lattice,{lmax/nsplit,2 lmax/nsplit}];
lattice3 = latticeSetDisplayCylinderLU[lattice,{2 lmax/nsplit,3 lmax/nsplit}];
lattice123 = latticeSetDisplayCylinderLU[lattice,{0 lmax/nsplit,3 lmax/nsplit}];


GraphicsColumn[
Reverse[
{showStem[lattice1,{{3,3},{5,3}},{5}],
showStem[lattice2,{{5,29},{8,29}},{30}],
showStem[lattice3,{{8,47},{5,42}},{50}]
}]
,Center
,Spacings->0
]
];

Ch5Transition := Module[{},
nPoints = 200;
rise = 0.02;
goldenLattice200 = latticeCreateDH[{GoldenAngle/(2\[Pi]),rise},{0,rise*nPoints}];
riseScalingZCylinder[z_] := quadraticRiseFallZLattice[goldenLattice200,z] ;
risingPhyllotaxisLatticeQuadratic = makeStretchedLattice[goldenLattice200,riseScalingZCylinder];
showTransitionLattice[risingPhyllotaxisLatticeQuadratic]
];



(* ::Input::Initialization:: *)
quadraticScaling[scale_] :=  Function[{z}, Ramp@Re@Sqrt[1- scale * z ]];
exponentialScaling :=  Function[{z}, Exp[- 2\[Pi] z ]];
interScaling[scale_] := Function[{z},
quadraticScaling[scale][z]*exponentialScaling[z]]

quadraticDiskLattice[lattice_] := Module[{diskscaling,res ,scale},
scale =  10;
diskscaling = Function[{xz},Module[{x,z,r},
{x,z}=xz;
r = quadraticScaling[scale][z];
r * { Cos[2 \[Pi] x], Sin[2\[Pi] x]} 
]];

res =  latticeSetCylinderLU[lattice,{0, 1/scale}];
res =  latticeSetScaling[res,"Disk"->diskscaling];

res
];
logarithmicDiskLattice[lattice_] := Module[{zMin,zMax,res },

{zMin,zMax}  = latticeGetCylinderLU[lattice];
res =  latticeSetCylinderLU[lattice,{0,zMax}];

res =  latticeSetScaling[res,"Disk"->Function[{xz},Module[{x,z,r},
{x,z}=xz;
r = exponentialScaling[z];
r * { Cos[2 \[Pi] x], Sin[2\[Pi] x]} 
]]];
res
];
intermediateDiskLattice[lattice_] := Module[{diskscaling,escaling,res ,scale},
scale =  10;
diskscaling = Function[{xz},Module[{x,z,r},
{x,z}=xz;
r = interScaling[scale][z];
r * { Cos[2 \[Pi] x], Sin[2\[Pi] x]} 
]];

res =  latticeSetCylinderLU[lattice,{0, 1/scale}];
res =  latticeSetScaling[res,"Disk"->diskscaling];

res

];


(* ::Input::Initialization:: *)
diskParastichyPlot[lattice_,m_,k_,style_] := Module[{func},
(*func =latticeDiskParastichyFunction[lattice,m,k];
*)
func =  First@latticeParastichyFunctions[lattice,m,k,"Disk"];
ParametricPlot[func[t],{t,0,1},PlotStyle->style]
];

diskParastichyLine[lattice_,central_] := Module[{g,disk},
disk = latticeGraphicRegion[lattice,"Disk"];
g = Show[
Graphics[
{
{figureStyle["CylinderColour"],disk
}
}
,PlotRange->RegionBounds[disk] * central
]
,MapIndexed[diskParastichyPlot[lattice,#1,0,Directive[Thick,diskParastichyColours@First[#2]]]&,Take[diskParastichyMN,2]]
,Graphics[
{
{White,Point[latticePoints[lattice,"Disk"]]}
}
]
];
g
];

diskSeeds[lattice_,voronoi_,central_] := Module[{g,mnList,disk,diskPoints,inner,outer,v},
disk = latticeGraphicRegion[lattice,"Disk"];
diskPoints = latticePoints[lattice,"Disk"];

g = Show[
Graphics[
{
{figureStyle["CylinderColour"],disk}}
,PlotRange->RegionBounds[disk] * central
]
,MapIndexed[diskParastichyPlot[lattice,#1,0,Directive[Thick,diskParastichyColours@First[#2]]]&,diskParastichyMN]

,Graphics[
{
{FaceForm[None],EdgeForm[Gray],voronoi}
}
]
];
g
];



(* ::Input::Initialization:: *)
makeVoronoi[lattice_] := Module[{disk,diskPoints,inner,outer,v},
disk = latticeGraphicRegion[lattice,"Disk"];
{inner,outer} = If[Head[disk]===Disk,
(* disk *) {Missing[],disk[[2]]},
(* annulus *)  disk[[2]]];
diskPoints = latticePoints[lattice,"Disk"];
vClipList = MeshPrimitives[VoronoiMesh[latticePoints[lattice,"Disk"]],2];
outerDisk = DiscretizeRegion[Disk[{0,0},outer*0.99]];
vClipList = Map[RegionIntersection[outerDisk,#]&,vClipList];
If[!MissingQ[inner],
innerDisk = DiscretizeRegion[Disk[{0,0},inner]];
vClipList = Map[RegionDifference[#,innerDisk]&,vClipList];
];
vClipList
];
makeVoronoiDiskLines[lattice_] := Module[{disk,diskPoints,inner,outer,v},
disk = latticeGraphicRegion[lattice,"Disk"];
{inner,outer} = If[Head[disk]===Disk,
(* disk *) {Missing[],disk[[2]]},
(* annulus *)  disk[[2]]];
diskPoints = latticePoints[lattice,"Disk"];
vClipList = Line[MeshPrimitives[VoronoiMesh[latticePoints[lattice,"Disk"]],1] /. Line[x_]->x];
outerDisk = DiscretizeRegion[Disk[{0,0},outer*0.99]];
vClipList =RegionIntersection[outerDisk,vClipList];
If[!MissingQ[inner],
innerDisk = DiscretizeRegion[Disk[{0,0},inner]];
vClipList = RegionDifference[vClipList,innerDisk];
];
MeshPrimitives[vClipList,1]
];

makeLatticeVoronoi[] :=Module[{nPoints,rise,store},
nPoints = 1500;
rise = 0.0001;
goldenLattice200 = latticeCreateDH[{GoldenAngle/(2\[Pi]),rise},{0,rise*nPoints}];

latticeLN =logarithmicDiskLattice[goldenLattice200];
latticeEA =quadraticDiskLattice[goldenLattice200];
latticeIM=intermediateDiskLattice[goldenLattice200];
voronoiLN = makeVoronoiDiskLines[latticeLN];
voronoiEA = makeVoronoiDiskLines[latticeEA];
voronoiIM = makeVoronoiDiskLines[latticeIM];

store =<|
"LN"-> <|"Lattice"-> latticeLN,"Voronoi"->voronoiLN|>,
"EA"-> <|"Lattice"-> latticeEA,"Voronoi"->voronoiEA|>,
"IM"-> <|"Lattice"-> latticeIM,"Voronoi"->voronoiIM|>
|>;
store
];


(* ::Input::Initialization:: *)

(*

makedisks := If[rebuildingData, Module[{nPoints,rise},
nPoints = 1500;
rise = 0.0001;
goldenLattice200 = latticeCreateDH[{GoldenAngle/(2\[Pi]),rise},{0,rise*nPoints}];

latticeLN =logarithmicDiskLattice[goldenLattice200];
latticeEA =quadraticDiskLattice[goldenLattice200];
latticeIM=intermediateDiskLattice[goldenLattice200];
voronoiLN = makeVoronoiDiskLines[latticeLN];
voronoiEA = makeVoronoiDiskLines[latticeEA];
voronoiIM = makeVoronoiDiskLines[latticeIM];
store= getTextbookData["Ch5DiskVoronoi"];
If[MissingQ[store],store=<||>];
store = Append[store,"LN"-> <|"Lattice"-> latticeLN,"Voronoi"->voronoiLN|>];
store = Append[store,"EA"-> <|"Lattice"-> latticeEA,"Voronoi"->voronoiEA|>];
store = Append[store,"IM"-> <|"Lattice"-> latticeIM,"Voronoi"->voronoiIM|>];
setTextbookData["Ch5DiskVoronoi",store];

],
Module[{store},
store= getTextbookData["Ch5DiskVoronoi"];
latticeLN= store["LN"]["Lattice"];
voronoiLN = store["LN"]["Voronoi"];
latticeEA = store["EA"]["Lattice"];
voronoiEA=store["EA"]["Voronoi"];
]
]

Module[{store},If[rebuildingData,
store= getTextbookData["Ch5DiskVoronoi"];
If[MissingQ[store],store=<||>];
makedisks[];
store = Append[store,"LN"-> <|"Lattice"-> latticeLN,"Voronoi"->voronoiLN|>];
store = Append[store,"EA"-> <|"Lattice"-> latticeEA,"Voronoi"->voronoiEA|>];
setTextbookData["Ch5DiskVoronoi",store];
]];
*)

diskParastichyMN =  Reverse@{21,34,55,89};
diskParastichyColours  =   <|1->jParastichyColour[1],2->jParastichyColour[2],3->jParastichyColour[3],4->Black|>;


(* ::Input::Initialization:: *)
makeCh5Transforms := Module[{central,store,showRow},
store=makeLatticeVoronoi[] ;
voronoiToShow=KeyTake[store,{"LN","EA"}];
central = 1.01;
GraphicsColumn[{
GraphicsRow[
Values@Map[diskParastichyLine[#Lattice,central]&,voronoiToShow]
],
GraphicsRow[
Values@Map[diskSeeds[#Lattice,#Voronoi,central]&,voronoiToShow]
]
}
]
];


(* ::Input::Initialization:: *)
setFontFamily = Directive[FontFamily->jStyle["FontFamily"],FontSize->14];
setBaseGill = BaseStyle->setFontFamily;

legendText = Map[Style[#,setFontFamily]&,ToString/@Reverse@diskParastichyMN];
gLabel = Graphics[
{Text["Logarithmic spiral",Scaled[{0.275,1}],{0,1}],
,Text["Equal area",Scaled[{0.725,1}],{0,1}]
}
];


(* ::Input::Initialization:: *)
Ch5Transforms := 
Show[Legended[
Show[{makeCh5Transforms, gLabel}]
,Placed[LineLegend[Reverse@Values[diskParastichyColours],legendText],{{1/2,1/2},{1/2,1/2}}]
]
,BaseStyle->setFontFamily
];



(* ::Input::Initialization:: *)
sunParaColours = Join[Values@diskParastichyColours,Part[ColorData[3,"ColorList"],{2,9,6}]];
sunflowerParastichyPlot[lattice_,m_,kRange_,styleIndex_,tRange_] := Module[{func,plot},
func[k_]:=  First@latticeParastichyFunctions[lattice,m,k,"Disk"];
plot[k_]:= ParametricPlot[func[k][t],{t,tRange[[1]],tRange[[2]]}
,PlotStyle->Directive[Thick,sunParaColours[[styleIndex]]]
];
Map[plot,kRange]
];


(* ::Input::Initialization:: *)

sunflowerSeeds[lattice_,voronoi_,central_] := Module[{g,mnList,disk,diskPoints,inner,outer,v},
disk = latticeGraphicRegion[lattice,"Disk"];
diskPoints = latticePoints[lattice,"Disk"];

g = Show[
Graphics[
{
{Lighter@figureStyle["CylinderColour"],disk}}
,PlotRange->RegionBounds[disk] * central
]
,Graphics[
{
{LightGray,Point[diskPoints]}
}
]
,Map[sunflowerParastichyPlot[lattice,#Parastichy,#k,#StyleIndex,#tRange]&,paraData]

,Graphics[
{
{White,voronoi}
}
]
];
g
];



(* ::Input::Initialization:: *)
paraData = {
<|"Parastichy"->5,"k"->{59},"StyleIndex"->7,"tRange"->{0.985,1}|>
,<|"Parastichy"->8,"k"->{66},"StyleIndex"->6,"tRange"->{0.95,0.999}|>
,<|"Parastichy"->13,"k"->{30},"StyleIndex"->5,"tRange"->{0.88,0.99}|>
,<|"Parastichy"->21,"k"->{65},"StyleIndex"->1,"tRange"->{0.6,.98}|>
,<|"Parastichy"->34,"k"->{68},"StyleIndex"->2,"tRange"->{0.0,0.9}|>
,<|"Parastichy"->55,"k"->{55},"StyleIndex"->3,"tRange"->{0,.8}|>
,<|"Parastichy"->89,"k"->{0},"StyleIndex"->4,"tRange"->{0,0.7}|>
};



(* ::Input::Initialization:: *)
central=1.01;
Ch5Sunflower :=
Show[Graphics[{},PlotRange->{{-1,2},{-1,1}}],
 Legended[sunflowerSeeds[latticeIM,voronoiIM,central],
Placed[
LineLegend[
Reverse@Map[sunParaColours[[#StyleIndex]]&,paraData]
,Reverse@Map[#Parastichy&,paraData]
,LabelStyle->jFont[12]
,LegendFunction->(Framed[#,Background->Lighter[jStyle["CylinderColour"]],FrameStyle->None]&)],{{0.9,0.5},{1,0.5}}]]
];



(* ::Input::Initialization:: *)
smoothRadiusFunctionV[radiusF_,nPoints_:20] := Module[{stemPoints,radiusFunction},
(* helper smooth function for v in [0,1] *)stemPoints = Table[radiusF[v/nPoints],{v,0,nPoints}];radiusFunction=BSplineFunction[stemPoints];
radiusFunction
];
bulgeFromPoints [pts_] :=  smoothRadiusFunctionV@Function[h,Interpolation[ Reverse /@pts,InterpolationOrder->1][h]];

Module[{rmin,rmax},
rmin = 1/20;
rmax = 6;
smoothBulgyV = bulgeFromPoints[ {{1,0},{1,0.4},{1,0.7},{rmax,0.8},{rmin,1}}];
widenV = bulgeFromPoints[ {{1,0},{1,1/20},{rmax,3/20},{rmax,1}}];

];


(* ::Input::Initialization:: *)


scaleZ01ToCylinder[cylinderLU_,bulgeFunction_] := Module[{zScale},
zScale[cylinderZ_] :=   (cylinderZ-cylinderLU[[1]])/(cylinderLU[[2]]-cylinderLU[[1]]);
Composition[bulgeFunction,zScale]
];


(* ::Input::Initialization:: *)
makeBulgeLattice[lattice_,bulgeFunction_,bulgeMax_] := Module[{bulgedXZ,bulgeLattice,cylinder},
bulgeLattice =lattice;
bulgedXZ [{x_,z_}] := { x * scaleZ01ToCylinder[latticeGetCylinderLU[bulgeLattice],bulgeFunction][z],z};
bulgeLattice = latticeSetScaling[bulgeLattice,"StemBulge"->bulgedXZ];
bulgeLattice = latticeSetScaling[bulgeLattice,"StemBulgeZ01"->bulgeFunction];
cylinder= latticeGetCylinder[bulgeLattice];
cylinder[[1]] = bulgeMax*cylinder[[1]] ;
bulgeLattice= latticeSetDisplayCylinder[bulgeLattice,cylinder];
bulgeLattice
];


(* ::Input::Initialization:: *)
extendLatticePoints[lattice_] := Module[{bulgeXZ,lPoints,rises,widthAtRises},
bulgeXZ = latticeScaling[lattice,"StemBulge"];
lPoints = latticePoints[lattice,"StemBulge"];
rises  = Last /@lPoints;
widthAtRises= Map[{2 * First@ bulgeXZ[{1/2,#}],0}&,rises];
Flatten[{lPoints-widthAtRises,lPoints,lPoints+widthAtRises},1]
];

voronoiLines[points_,region_] := Module[{vClipList},
vClipList = Line[MeshPrimitives[VoronoiMesh[points],1] /. Line[x_]->x];
RegionIntersection[region,vClipList]
];

bulgeVoronoiLines[lattice_] := Module[{eLPoints},
eLPoints = extendLatticePoints[lattice];
 voronoiLines[eLPoints,latticeGraphicRegion[lattice,"StemBulge"]]
];



(* ::Input::Initialization:: *)
pmax=5;
pineappleV = bulgeFromPoints[ 
{{1,0},{1,0.3},{pmax,0.35},{pmax,0.8},{1,0.9},{1,1}}];


(* ::Input::Initialization:: *)
makePineapple[rise_] := Module[{nPoints},
nPoints = 250;
pineappleLattice = makeBulgeLattice[latticeCreateDH[{N@GoldenAngle/(2 \[Pi]),rise},{0,rise*nPoints}],pineappleV,6];
pineappleLattice
];
pineappleLattice = makePineapple[0.030];

parametricPineappleV[s_] := Module[{scaleV},
scaleV:= Function[{v},(1-s)  + s  pineappleV[v]];
scaleV
];
rise =0.03 ;
nPoints = 250;

parametricPineapple[s_] := makeBulgeLattice[
latticeCreateDH[{N@GoldenAngle/(2 \[Pi]),rise},{0,rise*nPoints}],parametricPineappleV[s]
,6
];


(* ::Input::Initialization:: *)
makePineappleVoronoi[lattice_,mList_] := Module[{voronoiBulge,g},
voronoiBulge = bulgeVoronoiLines[lattice];

g=Show[
Graphics[{
{figureStyle["CylinderColour"],latticeGraphicRegion[lattice,"StemBulge"]}}
],
MapIndexed[bulgeParastichyPlot[lattice,#1,0,Directive[Thick,diskParastichyColours@First[#2]]]&,mList]
,
Graphics[{
{White,Point[latticePoints[lattice,"StemBulge"]]}
,{Gray,voronoiBulge}
}],
Axes->False
];
g
];
bulgeParastichyPlot[lattice_,m_,k_,style_] := Map[ParametricPlot[#[s],{s,0,1},PlotStyle->style]&,latticeParastichyFunctions[lattice,m,k,"StemBulge"]]

makeGraphicPineapple[lattice_,mList_] := Module[{voronoiBulge,g},

g={
Graphics[{
{figureStyle["CylinderColour"],latticeGraphicRegion[lattice,"StemBulge"]}}
],
MapIndexed[bulgeParastichyPlot[lattice,#1,0,Directive[Thick,diskParastichyColours@First[#2]]]&,mList]
,
Graphics[{
{White,Point[latticePoints[lattice,"StemBulge"]]}
}]
};
g
];




(* ::Input::Initialization:: *)



Ch5PineappleVoronoi := Show[makePineappleVoronoi[pineappleLattice,{5,8}]]



(* ::Input::Initialization:: *)
graphics2DTo3D[g_] := Module[{xy23,g23,res},
xy23[{x_,y_}] := {x,0,y};
g23[Polygon[x___]] := Polygon[Map[xy23,x]];
g23[line_Line] :=  Map[ xy23,line,{2}] /; VectorQ[line[[1,1]]];
g23[line_Line] :=  Map[ xy23,line,{3}];  
g23[Point[x___]] := Point[Map[xy23,x]]; 
g23[x_] := x;
res = Map[g23,List@@g,Infinity];
(*res = res /. jStyle["CylinderColour"]-> jStyle["CylinderColour3D"]
*)
res];



(* ::Input::Initialization:: *)
surfacePlot[stem_,vclip_] := Module[{shapeFunctionUV=stemShapeFunctionUV[stem]},ParametricPlot3D[ shapeFunctionUV[u,v],{u,0,1},{v,0,vclip}
,PlotStyle-> Directive[figureStyle["CylinderColour"],Opacity[1]]
,Mesh->None,Axes->None]
];
showStemBase[stem_] := Module[{cylinderL,cylinderU,baseHeight,base},
{cylinderL,cylinderU} = latticeGetCylinderLU[stem];
baseHeight = 0.05 * (cylinderU-cylinderL);
base = {Opacity[0.5],FaceForm[Brown],Cylinder[{{0,0,cylinderL-baseHeight},{0,0,cylinderL}},stemRadiusFunctionV[stem][0]]};
base
];

showStemParastichy[stem_,mList_] := Module[{},
MapIndexed[
(ParametricPlot3D[stemParastichyOfV[stem,#1,1][v],{v,0,1}
,PlotStyle->figureStyle["ParastichyColour"][First[#2]]
])&,mList]
];

showStemPoints[stem_] := Module[{},
Point[Values@stemPoints[stem]]
];

showStemPointNames[stem_] := Module[{},
KeyValueMap[Text[#1,#2]&,stemPoints[stem]]
];


showPineapple3D[stem_,mList_] := Module[{g,surface,base,displayCylinder,radius,rmax},
displayCylinder = latticeGetCylinder[stem];

base = showStemBase[stem] ;
surface = surfacePlot[stem,1];
g=Show[
Graphics3D[base,
PlotRange-> {displayCylinder[[1]],displayCylinder[[1]],displayCylinder[[2]]}]
,surface
,Graphics3D[{White,PointSize[Large],showStemPoints[stem]}]
, showStemParastichy[stem,mList]
,Axes->True
];
g
];



